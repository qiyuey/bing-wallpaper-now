name: Release

on:
  push:
    tags:
      - "[0-9]*.*.*"
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

env:
  NODE_VERSION: "24"
  RUST_BACKTRACE: short
  CARGO_INCREMENTAL: 0
  # Faster compile (trade a little optimization time for speed)
  CARGO_PROFILE_RELEASE_CODEGEN_UNITS: 256
  CARGO_PROFILE_RELEASE_LTO: "false"
  # Optimize Rust network operations
  CARGO_NET_GIT_FETCH_WITH_CLI: true
  CARGO_NET_RETRY: 10

jobs:
  changelog:
    name: Changelog
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    outputs:
      changelog: ${{ steps.changelog.outputs.content }}
      previous_tag: ${{ steps.previous_tag.outputs.tag }}
    steps:
      - name: Checkout (full history for tags/changelog)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Get previous tag
        id: previous_tag
        shell: bash
        run: |
          PREVIOUS_TAG=$(git tag --sort=-v:refname | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | grep -v "${{ github.ref_name }}" | head -n 1)
          echo "tag=$PREVIOUS_TAG" >> $GITHUB_OUTPUT
          echo "Previous tag: $PREVIOUS_TAG"

      - name: Extract changelog
        id: changelog
        shell: bash
        run: |
          # Extract changelog for current version (without square brackets)
          CHANGELOG=$(sed -n "/^## ${{ github.ref_name }}/,/^## /p" CHANGELOG.md | sed '1d;$d' | sed '/^$/d')
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="请查看完整的更新日志: [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md)"
          fi
          echo "content<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  release:
    name: Create or Update Release
    needs: changelog
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (for tag context)
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Generate release body (envsubst template)
        shell: bash
        run: |
          export VERSION="${{ github.ref_name }}"
          export REPOSITORY="${{ github.repository }}"
          export PREVIOUS_TAG="${{ needs.changelog.outputs.previous_tag }}"
          if [ -n "$PREVIOUS_TAG" ]; then
            export COMPARE_LINK="[${PREVIOUS_TAG}...${VERSION}](https://github.com/${REPOSITORY}/compare/${PREVIOUS_TAG}...${VERSION})"
          else
            export COMPARE_LINK="[查看提交历史](https://github.com/${REPOSITORY}/commits/${VERSION})"
          fi
          # Write changelog to temp file first to handle multiline content safely
          # Use printf to preserve newlines and special characters (without adding extra newline)
          printf '%s' "${{ needs.changelog.outputs.changelog }}" > changelog_temp.txt
          # Export CHANGELOG by reading from file (handles multiline safely)
          export CHANGELOG=$(cat changelog_temp.txt)
          envsubst < .github/release_body_template.md > release_body.md
          rm -f changelog_temp.txt
          echo "Generated release_body.md preview (first 60 lines):"
          sed -n '1,60p' release_body.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          name: "Bing Wallpaper Now ${{ github.ref_name }}"
          draft: false
          prerelease: false
          make_latest: true
          body_path: release_body.md

  frontend:
    name: Frontend Build
    needs: release
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Compute pnpm store path
        id: pnpm-store
        shell: bash
        run: |
          STORE_PATH=$(pnpm store path --silent 2>/dev/null || echo "")
          if [ -z "$STORE_PATH" ]; then
            # Fallback to default pnpm store location based on OS
            if [ "$RUNNER_OS" = "Windows" ]; then
              STORE_PATH="$LOCALAPPDATA/pnpm/store"
            elif [ "$RUNNER_OS" = "macOS" ]; then
              STORE_PATH="$HOME/Library/pnpm/store"
            else
              STORE_PATH="$HOME/.local/share/pnpm/store"
            fi
          fi
          echo "STORE_PATH=$STORE_PATH" >> $GITHUB_ENV
          echo "store_path=$STORE_PATH" >> $GITHUB_OUTPUT
          echo "Computed pnpm store path: $STORE_PATH"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.store_path }}
          key: pnpm-store-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-${{ runner.arch }}-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile --prefer-offline

      - name: Build frontend
        run: pnpm run build

      - name: Upload dist artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist
          retention-days: 3

  bundle:
    name: Bundle (${{ matrix.platform }})
    needs: [frontend, release]
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: "Windows (x64)"
            os: windows-latest
          - platform: "Windows (ARM64)"
            os: windows-11-arm
          - platform: "macOS (Apple Silicon)"
            os: macos-latest
          - platform: "macOS (Intel)"
            os: macos-15-intel
          - platform: "Ubuntu (x64)"
            os: ubuntu-24.04
          - platform: "Ubuntu (ARM64)"
            os: ubuntu-24.04-arm

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Download frontend dist
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: Compute pnpm store path
        id: pnpm-store
        shell: bash
        run: |
          STORE_PATH=$(pnpm store path --silent 2>/dev/null || echo "")
          if [ -z "$STORE_PATH" ]; then
            # Fallback to default pnpm store location based on OS
            if [ "$RUNNER_OS" = "Windows" ]; then
              STORE_PATH="$LOCALAPPDATA/pnpm/store"
            elif [ "$RUNNER_OS" = "macOS" ]; then
              STORE_PATH="$HOME/Library/pnpm/store"
            else
              STORE_PATH="$HOME/.local/share/pnpm/store"
            fi
          fi
          echo "STORE_PATH=$STORE_PATH" >> $GITHUB_ENV
          echo "store_path=$STORE_PATH" >> $GITHUB_OUTPUT
          echo "Computed pnpm store path: $STORE_PATH"

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-store.outputs.store_path }}
          key: pnpm-store-${{ runner.os }}-${{ runner.arch }}-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            pnpm-store-${{ runner.os }}-${{ runner.arch }}-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile --prefer-offline

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Rust Cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
          # Cache on failure to avoid rebuilding on transient errors
          cache-on-failure: true

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            patchelf \
            xdg-utils

      - name: Patch tauri.conf.json (skip beforeBuildCommand)
        shell: bash
        run: |
          if command -v jq &> /dev/null; then
            jq '.build.beforeBuildCommand = ""' src-tauri/tauri.conf.json > src-tauri/tauri.conf.json.tmp
            mv src-tauri/tauri.conf.json.tmp src-tauri/tauri.conf.json
          else
            sed -i.bak 's/"beforeBuildCommand"[[:space:]]*:[[:space:]]*"[^"]*"/"beforeBuildCommand": ""/' src-tauri/tauri.conf.json
          fi

      - name: Build Tauri app (skip frontend build)
        id: tauri-build
        uses: tauri-apps/tauri-action@v0
        continue-on-error: false
        with:
          projectPath: src-tauri
          # Omit tagName/releaseName/releaseId to build only without uploading
          # The action will automatically execute build command
          tauriScript: pnpm tauri

      - name: Verify build output
        shell: bash
        run: |
          if [ ! -d "src-tauri/target/release/bundle" ]; then
            echo "Error: Bundle directory not found"
            ls -la src-tauri/target/release/ 2>/dev/null || echo "Release directory not found"
            exit 1
          fi
          echo "Build successful. Bundle files:"
          find src-tauri/target/release/bundle -type f | head -10

      - name: Upload bundle to Release
        shell: bash
        run: |
          # Determine file patterns based on OS
          if [ "${{ runner.os }}" == "Windows" ]; then
            PATTERNS=(
              "src-tauri/target/release/bundle/msi/*.msi"
              "src-tauri/target/release/bundle/nsis/*.exe"
            )
          elif [ "${{ runner.os }}" == "macOS" ]; then
            PATTERNS=(
              "src-tauri/target/release/bundle/dmg/*.dmg"
            )
          else
            PATTERNS=(
              "src-tauri/target/release/bundle/deb/*.deb"
              "src-tauri/target/release/bundle/rpm/*.rpm"
              "src-tauri/target/release/bundle/appimage/*.AppImage"
            )
          fi
          
          # Find and collect all matching files
          FILES=()
          shopt -s nullglob
          for pattern in "${PATTERNS[@]}"; do
            for file in $pattern; do
              [ -f "$file" ] && FILES+=("$file")
            done
          done
          shopt -u nullglob
          
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "Error: No bundle files found for this platform"
            find src-tauri/target/release/bundle -type f 2>/dev/null || echo "Bundle directory not found"
            exit 1
          fi
          
          echo "Uploading ${#FILES[@]} file(s)..."
          gh release upload "${{ github.ref_name }}" "${FILES[@]}" --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
